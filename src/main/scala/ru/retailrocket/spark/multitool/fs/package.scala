package ru.retailrocket.spark.multitool

import org.apache.hadoop.fs._
import org.apache.hadoop.conf.Configuration
import org.apache.hadoop.io.compress.CompressionCodec
import org.apache.spark.rdd.RDD
import java.io.{BufferedReader, InputStreamReader, FileInputStream, FileOutputStream, File}


package object fs {

  def constantPostfix(postfix: String): Path => String = { _ => postfix }

  val timestampPostfix: Path => String = { _ =>
    s"_${System.currentTimeMillis()}"
  }


  /**
   * Makes sure given `path` doesn't exist.
   *
   * Doesn't do anything if `path` doesn't exist.
   * Otherwise adds postfix generated by `postfix` function to its filename,
   * __makes sure__ new path doesn't exists, then renames current `path` using
   * name with generated postfix.
   *
   * __All files are guarantied not to be deleted.__
   *
   * @param fs hadoop file system
   * @param postfix postfix generator
   * @param path path to be deleted.
   */
  def makeFree(fs: FileSystem, postfix: Path => String = timestampPostfix)
               (path: Path): Unit = {
    if (fs.exists(path)) {
      val copy = new Path(path.getParent, path.getName + postfix(path))
      makeFree(fs, postfix)(copy)

      fs.rename(path, copy)
    }
  }

  def saveViaTmp(tmpRoot: String, filename: String, codec: Class[_ <: CompressionCodec])
                (data: RDD[String]): Unit = {
    actionViaTmp(tmpRoot, filename) { tmpPath: Path =>
      data.saveAsTextFile(tmpPath.toString, codec)
    }
  }

  def saveViaTmp(tmpRoot: String, filename: String)
                (data: RDD[String]): Unit = {
    actionViaTmp(tmpRoot, filename) { tmpPath: Path =>
      data.saveAsTextFile(tmpPath.toString)
    }
  }

  def actionViaTmp(tmpRoot: String, filename: String)
                  (body: (Path) => Unit): Unit = {
    val fs = FileSystem.get(new Configuration())

    val tmpRootPath = new Path(tmpRoot)
    val distPath = new Path(filename)

    val distRootPath = distPath.getParent
    val tmpPath = new Path(tmpRootPath, distPath.getName)

    makeFree(fs)(tmpPath)
    fs.mkdirs(tmpRootPath)
    body(tmpPath)

    makeFree(fs)(distPath)
    fs.mkdirs(distRootPath)
    fs.rename(tmpPath, distPath)
  }

  def rename(src: String, dst: String) = {
    val srcPath = new Path(src)
    val dstPath = new Path(dst)

    val fs = FileSystem.get(new Configuration())
    fs.rename(srcPath, dstPath)
  }

  def replace(src: String, dst: String) = {
    val srcPath = new Path(src)
    val dstPath = new Path(dst)

    val fs = FileSystem.get(new Configuration())
    if(fs.exists(dstPath)) fs.delete(dstPath, true)
    fs.rename(srcPath, dstPath)
  }

  def storeLocal(data: String, path: String) {
    val out = new FileOutputStream(path)
    val bytes = data.getBytes
    out.write(bytes, 0, bytes.size)
    out.close()
  }

  def storeHdfs(data: String, path: String) {
    val conf = new Configuration()
    val fs = FileSystem.get(conf)
    val out = fs.create(new Path(path))
    val bytes = data.getBytes
    out.write(bytes, 0, bytes.size)
    out.close()
  }
}
